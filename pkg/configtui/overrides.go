// Package configtui provides a TUI for managing CBT model overrides.
package configtui

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

// CBTOverrides represents the .cbt-overrides.yaml structure.
type CBTOverrides struct {
	Models ModelsConfig `yaml:"models"`
}

// ModelsConfig holds the models configuration section.
type ModelsConfig struct {
	Env            map[string]string        `yaml:"env,omitempty"`
	DefaultEnabled *bool                    `yaml:"defaultEnabled,omitempty"`
	Overrides      map[string]ModelOverride `yaml:"overrides,omitempty"`
}

// ModelOverride holds configuration for a single model override.
type ModelOverride struct {
	Enabled *bool          `yaml:"enabled,omitempty"`
	Config  map[string]any `yaml:"config,omitempty"`
}

// LoadOverrides reads .cbt-overrides.yaml if it exists.
// Returns (overrides, fileExists, error).
// Returns a default structure if the file doesn't exist (fileExists=false).
func LoadOverrides(path string) (*CBTOverrides, bool, error) {
	overrides := &CBTOverrides{
		Models: ModelsConfig{
			Env:       make(map[string]string, 2),
			Overrides: make(map[string]ModelOverride),
		},
	}

	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return overrides, false, nil
		}

		return nil, false, fmt.Errorf("failed to read overrides file: %w", err)
	}

	if err := yaml.Unmarshal(data, overrides); err != nil {
		return nil, true, fmt.Errorf("failed to parse overrides file: %w", err)
	}

	// Ensure maps are initialized.
	if overrides.Models.Env == nil {
		overrides.Models.Env = make(map[string]string, 2)
	}

	if overrides.Models.Overrides == nil {
		overrides.Models.Overrides = make(map[string]ModelOverride, 8)
	}

	return overrides, true, nil
}

// SaveOverrides writes the configuration to .cbt-overrides.yaml.
// Only writes models that are disabled (enabled: false).
// Preserves existing config blocks for models.
func SaveOverrides(path string, m *Model, existingOverrides *CBTOverrides) error {
	return SaveOverridesFromEntries(
		path,
		m.externalModels,
		m.transformationModels,
		m.envMinTimestamp,
		m.envTimestampEnabled,
		m.envMinBlock,
		m.envBlockEnabled,
		existingOverrides,
		existingOverrides.Models.DefaultEnabled,
	)
}

// SaveOverridesFromEntries writes the configuration to .cbt-overrides.yaml
// from plain data (no TUI dependency).
// When defaultEnabled is nil or true, writes disabled models (denylist mode).
// When defaultEnabled is false, writes enabled models (allowlist mode).
// Preserves existing config blocks for models.
func SaveOverridesFromEntries(
	path string,
	externalModels []ModelEntry,
	transformationModels []ModelEntry,
	envMinTimestamp string,
	envTimestampEnabled bool,
	envMinBlock string,
	envBlockEnabled bool,
	existingOverrides *CBTOverrides,
	defaultEnabled *bool,
) error {
	// Ensure the directory exists.
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Build the YAML manually to handle comments for env vars.
	var sb strings.Builder

	sb.WriteString("# CBT Configuration Overrides\n")
	sb.WriteString("# Generated by: xcli lab overrides\n")
	sb.WriteString("#\n")
	sb.WriteString("# Docs: https://github.com/ethpandaops/cbt\n")
	sb.WriteString("\n")
	sb.WriteString("models:\n")

	// Write defaultEnabled if explicitly set to false (allowlist mode).
	isAllowlist := defaultEnabled != nil && !*defaultEnabled
	if isAllowlist {
		sb.WriteString("  defaultEnabled: false\n")
	}

	sb.WriteString("  env:\n")

	// Write EXTERNAL_MODEL_MIN_TIMESTAMP.
	if envTimestampEnabled && envMinTimestamp != "" {
		fmt.Fprintf(&sb, "    EXTERNAL_MODEL_MIN_TIMESTAMP: \"%s\"\n", envMinTimestamp)
	} else {
		value := envMinTimestamp
		if value == "" {
			value = "0"
		}

		fmt.Fprintf(&sb, "    # EXTERNAL_MODEL_MIN_TIMESTAMP: \"%s\"\n", value)
	}

	// Write EXTERNAL_MODEL_MIN_BLOCK.
	if envBlockEnabled && envMinBlock != "" {
		fmt.Fprintf(&sb, "    EXTERNAL_MODEL_MIN_BLOCK: \"%s\"\n", envMinBlock)
	} else {
		value := envMinBlock
		if value == "" {
			value = "0"
		}

		fmt.Fprintf(&sb, "    # EXTERNAL_MODEL_MIN_BLOCK: \"%s\"\n", value)
	}

	// Collect models to write in overrides section.
	// In allowlist mode (defaultEnabled: false): write disabled models with enabled: false,
	// plus any enabled models that have existing config blocks to preserve.
	// In denylist mode (default): write only disabled models.
	overrideModels := make([]string, 0, len(externalModels)+len(transformationModels))

	for _, model := range externalModels {
		if !model.Enabled {
			overrideModels = append(overrideModels, model.OverrideKey)
		}
	}

	for _, model := range transformationModels {
		if !model.Enabled {
			overrideModels = append(overrideModels, model.OverrideKey)
		}
	}

	// Sort for consistent output.
	sort.Strings(overrideModels)

	// In allowlist mode, also collect enabled models that have config to preserve.
	var enabledWithConfig []string

	if isAllowlist && existingOverrides != nil {
		for _, model := range externalModels {
			if model.Enabled {
				if existing, ok := existingOverrides.Models.Overrides[model.OverrideKey]; ok && existing.Config != nil {
					enabledWithConfig = append(enabledWithConfig, model.OverrideKey)
				}
			}
		}

		for _, model := range transformationModels {
			if model.Enabled {
				if existing, ok := existingOverrides.Models.Overrides[model.OverrideKey]; ok && existing.Config != nil {
					enabledWithConfig = append(enabledWithConfig, model.OverrideKey)
				}
			}
		}

		sort.Strings(enabledWithConfig)
	}

	// Write overrides section.
	sb.WriteString("  overrides:\n")

	if len(overrideModels) == 0 && len(enabledWithConfig) == 0 {
		if isAllowlist {
			sb.WriteString("    {} # All models disabled by default\n")
		} else {
			sb.WriteString("    {} # No disabled models\n")
		}
	} else {
		// Write enabled models with config (allowlist mode only).
		for _, name := range enabledWithConfig {
			fmt.Fprintf(&sb, "    %s:\n", name)
			writeModelConfig(&sb, existingOverrides, name)
		}

		// Write disabled models.
		for _, name := range overrideModels {
			fmt.Fprintf(&sb, "    %s:\n", name)
			sb.WriteString("      enabled: false\n")
			writeModelConfig(&sb, existingOverrides, name)
		}
	}

	if err := os.WriteFile(path, []byte(sb.String()), 0600); err != nil {
		return fmt.Errorf("failed to write overrides file: %w", err)
	}

	return nil
}

// writeModelConfig writes the preserved config block for a model override entry.
func writeModelConfig(sb *strings.Builder, existingOverrides *CBTOverrides, name string) {
	if existingOverrides == nil {
		return
	}

	existing, ok := existingOverrides.Models.Overrides[name]
	if !ok || existing.Config == nil {
		return
	}

	configYAML, err := yaml.Marshal(map[string]any{"config": existing.Config})
	if err != nil {
		return
	}

	lines := strings.Split(strings.TrimSpace(string(configYAML)), "\n")
	for _, line := range lines {
		fmt.Fprintf(sb, "      %s\n", line)
	}
}

// IsModelDisabled checks if a model is disabled in the overrides.
// When DefaultEnabled is false (allowlist mode), unlisted models are disabled.
func IsModelDisabled(overrides *CBTOverrides, modelName string) bool {
	if overrides == nil || overrides.Models.Overrides == nil {
		if overrides != nil && overrides.Models.DefaultEnabled != nil && !*overrides.Models.DefaultEnabled {
			return true
		}

		return false
	}

	if override, ok := overrides.Models.Overrides[modelName]; ok {
		if override.Enabled != nil && !*override.Enabled {
			return true
		}

		// Explicitly listed without enabled:false — enabled.
		return false
	}

	// Not in overrides — check default.
	if overrides.Models.DefaultEnabled != nil && !*overrides.Models.DefaultEnabled {
		return true
	}

	return false
}
