// Package configtui provides a TUI for managing CBT model overrides.
package configtui

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

// CBTOverrides represents the .cbt-overrides.yaml structure.
type CBTOverrides struct {
	Models ModelsConfig `yaml:"models"`
}

// ModelsConfig holds the models configuration section.
type ModelsConfig struct {
	Env       map[string]string        `yaml:"env,omitempty"`
	Overrides map[string]ModelOverride `yaml:"overrides,omitempty"`
}

// ModelOverride holds configuration for a single model override.
type ModelOverride struct {
	Enabled *bool          `yaml:"enabled,omitempty"`
	Config  map[string]any `yaml:"config,omitempty"`
}

// LoadOverrides reads .cbt-overrides.yaml if it exists.
// Returns (overrides, fileExists, error).
// Returns a default structure if the file doesn't exist (fileExists=false).
func LoadOverrides(path string) (*CBTOverrides, bool, error) {
	overrides := &CBTOverrides{
		Models: ModelsConfig{
			Env:       make(map[string]string, 2),
			Overrides: make(map[string]ModelOverride),
		},
	}

	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return overrides, false, nil
		}

		return nil, false, fmt.Errorf("failed to read overrides file: %w", err)
	}

	if err := yaml.Unmarshal(data, overrides); err != nil {
		return nil, true, fmt.Errorf("failed to parse overrides file: %w", err)
	}

	// Ensure maps are initialized.
	if overrides.Models.Env == nil {
		overrides.Models.Env = make(map[string]string, 2)
	}

	if overrides.Models.Overrides == nil {
		overrides.Models.Overrides = make(map[string]ModelOverride, 8)
	}

	return overrides, true, nil
}

// SaveOverrides writes the configuration to .cbt-overrides.yaml.
// Only writes models that are disabled (enabled: false).
// Preserves existing config blocks for models.
func SaveOverrides(path string, m *Model, existingOverrides *CBTOverrides) error {
	return SaveOverridesFromEntries(
		path,
		m.externalModels,
		m.transformationModels,
		m.envMinTimestamp,
		m.envTimestampEnabled,
		m.envMinBlock,
		m.envBlockEnabled,
		existingOverrides,
	)
}

// SaveOverridesFromEntries writes the configuration to .cbt-overrides.yaml
// from plain data (no TUI dependency). Only writes models that are disabled.
// Preserves existing config blocks for models.
func SaveOverridesFromEntries(
	path string,
	externalModels []ModelEntry,
	transformationModels []ModelEntry,
	envMinTimestamp string,
	envTimestampEnabled bool,
	envMinBlock string,
	envBlockEnabled bool,
	existingOverrides *CBTOverrides,
) error {
	// Ensure the directory exists.
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Build the YAML manually to handle comments for env vars.
	var sb strings.Builder

	sb.WriteString("# CBT Configuration Overrides\n")
	sb.WriteString("# Generated by: xcli lab overrides\n")
	sb.WriteString("#\n")
	sb.WriteString("# Docs: https://github.com/ethpandaops/cbt\n")
	sb.WriteString("\n")
	sb.WriteString("models:\n")
	sb.WriteString("  env:\n")

	// Write EXTERNAL_MODEL_MIN_TIMESTAMP.
	if envTimestampEnabled && envMinTimestamp != "" {
		fmt.Fprintf(&sb, "    EXTERNAL_MODEL_MIN_TIMESTAMP: \"%s\"\n", envMinTimestamp)
	} else {
		value := envMinTimestamp
		if value == "" {
			value = "0"
		}

		fmt.Fprintf(&sb, "    # EXTERNAL_MODEL_MIN_TIMESTAMP: \"%s\"\n", value)
	}

	// Write EXTERNAL_MODEL_MIN_BLOCK.
	if envBlockEnabled && envMinBlock != "" {
		fmt.Fprintf(&sb, "    EXTERNAL_MODEL_MIN_BLOCK: \"%s\"\n", envMinBlock)
	} else {
		value := envMinBlock
		if value == "" {
			value = "0"
		}

		fmt.Fprintf(&sb, "    # EXTERNAL_MODEL_MIN_BLOCK: \"%s\"\n", value)
	}

	// Collect all disabled models.
	disabledModels := make([]string, 0, len(externalModels)+len(transformationModels))

	for _, model := range externalModels {
		if !model.Enabled {
			disabledModels = append(disabledModels, model.OverrideKey)
		}
	}

	for _, model := range transformationModels {
		if !model.Enabled {
			disabledModels = append(disabledModels, model.OverrideKey)
		}
	}

	// Sort for consistent output.
	sort.Strings(disabledModels)

	// Write overrides section.
	sb.WriteString("  overrides:\n")

	if len(disabledModels) == 0 {
		sb.WriteString("    {} # No disabled models\n")
	} else {
		for _, name := range disabledModels {
			fmt.Fprintf(&sb, "    %s:\n", name)
			sb.WriteString("      enabled: false\n")

			// Preserve any existing config for this model.
			if existingOverrides != nil {
				if existing, ok := existingOverrides.Models.Overrides[name]; ok && existing.Config != nil {
					configYAML, err := yaml.Marshal(map[string]any{"config": existing.Config})
					if err == nil {
						// Indent and add the config section.
						lines := strings.Split(strings.TrimSpace(string(configYAML)), "\n")
						for _, line := range lines {
							fmt.Fprintf(&sb, "      %s\n", line)
						}
					}
				}
			}
		}
	}

	if err := os.WriteFile(path, []byte(sb.String()), 0600); err != nil {
		return fmt.Errorf("failed to write overrides file: %w", err)
	}

	return nil
}

// IsModelDisabled checks if a model is disabled in the overrides.
func IsModelDisabled(overrides *CBTOverrides, modelName string) bool {
	if overrides == nil || overrides.Models.Overrides == nil {
		return false
	}

	if override, ok := overrides.Models.Overrides[modelName]; ok {
		if override.Enabled != nil && !*override.Enabled {
			return true
		}
	}

	return false
}
